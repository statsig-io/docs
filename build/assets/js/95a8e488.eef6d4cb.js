"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[14665],{94324:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>g,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var s=n(74848),r=n(28453),a=n(11470),i=n(19365);const l={title:"Client Persistent Assignment",sidebar_label:"Client Persistent Assignment",slug:"/client/concepts/persistent_assignment",keywords:["owner:brock"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},o=void 0,c={id:"client/concepts/persistent_assignment",title:"Client Persistent Assignment",description:"Persistent assignment allows you to ensure that a user's variant stays consistent while an experiment is running, regardless of changes to allocation or targeting.",source:"@site/docs/client/concepts/persistent_assignment.mdx",sourceDirName:"client/concepts",slug:"/client/concepts/persistent_assignment",permalink:"/client/concepts/persistent_assignment",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/client/concepts/persistent_assignment.mdx",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Client Persistent Assignment",sidebar_label:"Client Persistent Assignment",slug:"/client/concepts/persistent_assignment",keywords:["owner:brock"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"api",previous:{title:"Legacy PHP",permalink:"/server/phpSDK"},next:{title:"Server Persistent Assignment",permalink:"/server/concepts/persistent_assignment"}},u={},d=[{value:"Persistent Storage",id:"persistent-storage",level:2},{value:"Persistent Storage Logic",id:"persistent-storage-logic",level:3},{value:"Example usage",id:"example-usage",level:3},{value:"Synchronous Persistent Evaluations",id:"synchronous-persistent-evaluations",level:4},{value:"Asynchronous Persistent Evaluations",id:"asynchronous-persistent-evaluations",level:4},{value:"Support in iOS and Android SDKs",id:"support-in-ios-and-android-sdks",level:2},{value:"Swift:",id:"swift",level:4},{value:"Objective C:",id:"objective-c",level:4},{value:"Java:",id:"java",level:4},{value:"Kotlin:",id:"kotlin",level:4}];function p(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Persistent assignment allows you to ensure that a user's variant stays consistent while an experiment is running, regardless of changes to allocation or targeting."}),"\n",(0,s.jsx)(t.h2,{id:"persistent-storage",children:"Persistent Storage"}),"\n",(0,s.jsxs)(t.p,{children:['Persistent storage takes an "adapter" approach, allowing you to plug in a storage solution of your choice to store assignments, which can then be referenced later to ensure a user stays in the same bucket. You can implement an adapter that uses Local Storage, or one that uses remote storage, to enable persistence across multiple devices.\nThe user persistent storage interface consists of just a ',(0,s.jsx)(t.code,{children:"load"}),"/",(0,s.jsx)(t.code,{children:"loadAsync"}),", ",(0,s.jsx)(t.code,{children:"save"}),", ",(0,s.jsx)(t.code,{children:"delete"})," API for read/write operations."]}),"\n",(0,s.jsxs)(t.admonition,{type:"info",children:[(0,s.jsx)(t.p,{children:"Persistent Storage is currently supported on:"}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The modern ",(0,s.jsx)(t.a,{href:"/client/javascript-sdk",children:(0,s.jsx)(t.code,{children:"Javascript,"})})," ",(0,s.jsx)(t.a,{href:"/client/javascript-sdk/react",children:(0,s.jsx)(t.code,{children:"React"})}),", and ",(0,s.jsx)(t.a,{href:"/client/javascript-sdk/react-native",children:(0,s.jsx)(t.code,{children:"React Native"})})," SDKs, including on-device evaluation"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/client/androidOnDeviceEvaluationSDK",children:(0,s.jsx)(t.code,{children:"Android, on-device evaluation"})})," only"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/client/swiftOnDeviceEvaluationSDK",children:(0,s.jsx)(t.code,{children:"iOS, on-device evaluation"})})," only"]}),"\n",(0,s.jsxs)(t.li,{children:["See ",(0,s.jsx)(t.a,{href:"#support-in-ios-and-android-sdks",children:"below"})," for more information on Android and iOS Support"]}),"\n"]})]}),"\n",(0,s.jsx)(t.h3,{id:"persistent-storage-logic",children:"Persistent Storage Logic"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Providing a storage adapter on Statsig initialization will give the SDK access to read & write on your custom storage"}),"\n",(0,s.jsxs)(t.li,{children:["Providing user persisted values to ",(0,s.jsx)(t.code,{children:"get_experiment"})," will inform the SDK to","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"save"})," the evaluation of the current user ",(0,s.jsx)(t.strong,{children:"on first evaluation"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"load"})," the previously saved evaluation of a persisted user ",(0,s.jsx)(t.strong,{children:"on subsequent evaluations"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"delete"})," the previously saved evaluation of a persisted user if the experiment is no longer active"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Not providing user persisted values to ",(0,s.jsx)(t.code,{children:"get_experiment"})," will ",(0,s.jsx)(t.strong,{children:"delete"})," a previously saved evaluation"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"example-usage",children:"Example usage"}),"\n",(0,s.jsxs)(a.A,{groupId:"client-sdk-lang-choice",defaultValue:"js-mono",values:[{label:"Javascript",value:"js-mono"},{label:"React",value:"react"},{label:"JS On-Device Eval",value:"js-mono-on-device"},{label:"Android On-Device Eval",value:"androidOnDeviceEvaluationSDK"},{label:"JS (legacy)",value:"old-js"}],children:[(0,s.jsx)(i.A,{value:"js-mono",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"import { StatsigClient } from '@statsig/js-client';\nimport { UserPersistentOverrideAdapter } from '@statsig/js-user-persisted-storage';\n\n// Custom storage implementation using localStorage\nclass LocalStorageUserPersistedStorage {\n  load(key) {\n    return JSON.parse(localStorage.getItem(key) ?? '{}');\n  }\n\n  save(key, experiment, data) {\n    const values = JSON.parse(localStorage.getItem(key) ?? '{}');\n    values[experiment] = JSON.parse(data);\n    localStorage.setItem(key, JSON.stringify(values));\n  }\n\n  delete(key, experiment) {\n    const data = JSON.parse(localStorage.getItem(key) ?? '{}');\n    delete data[experiment];\n    localStorage.setItem(key, JSON.stringify(data));\n  }\n}\n\nconst storage = new LocalStorageUserPersistedStorage();\nconst adapter = new UserPersistentOverrideAdapter(storage);\nconst client = new StatsigClient('client-key', { overrideAdapter: adapter });\n\nawait client.initializeAsync({ userID: \"123\" });\n\nconst user = { userID: \"123\" };\nconst userPersistedValues = adapter.loadUserPersistedValues(user, 'userID');\n\nconst experiment = client.getExperiment('active_experiment', { userPersistedValues });\nconsole.log(experiment.getGroupName()); // 'Control'\n\n// Switch to different user - will maintain same experiment group due to persistence\nconst newUser = { userID: \"456\" };\nconst newExperiment = client.getExperiment('active_experiment', { userPersistedValues });\nconsole.log(newExperiment.getGroupName()); // Still 'Control'\n"})})}),(0,s.jsx)(i.A,{value:"react",children:(0,s.jsxs)(t.p,{children:["The Syntax for react matches vanilla Javascript - for a full implementation example, you can refer to our ",(0,s.jsx)(t.a,{href:"https://github.com/statsig-io/js-client-monorepo/tree/main/samples/next-js/src/app/persisted-user-storage-example",children:"Persistent Storage Example"})," in Next.js."]})}),(0,s.jsxs)(i.A,{value:"androidOnDeviceEvaluationSDK",children:[(0,s.jsx)(t.h4,{id:"synchronous-persistent-evaluations",children:"Synchronous Persistent Evaluations"}),(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"UserPersistentStorageInterface"})," exposes two methods for synchronous persistent storage, which will be called by default when evaluating an experiment."]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"interface UserPersistentStorageInterface {\n    suspend fun load(key: String): PersistedValues\n    fun save(key: String, experimentName: String, data: String)\n    fun delete(key: String, experiment: String)\n    ...\n}\n"})}),(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"key"}),' string is a combination of ID and ID Type: e.g. "123',":userID",'" or "abc',":stableID",'" which the SDK will construct and call ',(0,s.jsx)(t.code,{children:"get"})," and ",(0,s.jsx)(t.code,{children:"set"})," on by default"]}),(0,s.jsx)(t.p,{children:"You can use this interface to persist evaluations synchronously to local storage.  If you need an async interface, read on."}),(0,s.jsx)(t.h4,{id:"asynchronous-persistent-evaluations",children:"Asynchronous Persistent Evaluations"}),(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"UserPersistentStorageInterface"})," exposes two methods for asynchronous persistent evaluations. Because the ",(0,s.jsx)(t.code,{children:"getExperiment"})," call is synchronous, you must load the value first, and pass it in as ",(0,s.jsx)(t.code,{children:"userPersistedValues"})]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-kotlin",children:"interface UserPersistentStorageInterface {\n    fun loadAsync(key: String, callback: IPersistentStorageCallback)\n    fun save(key: String, experimentName: String, data: String)\n    fun delete(key: String, experiment: String)\n    ...\n}\ninterface IPersistentStorageCallback {\n    fun onLoaded(values: PersistedValues)\n}\n"})}),(0,s.jsx)(t.p,{children:"For your convenience, we've created a top level method to load the value for a given user and ID Type:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-kotlin",children:"// Asynchronous load values\nval userPersistedValues = Statsig.client.loadUserPersistedValuesAsync(\n  user: StatsigUser,\n  idType: string, // userID, stableID, customIDxyz, etc\n  callback: IPersistentStorageCallback\n);\n\n// Synchronous load values \nval userPersistedvalues = Statsig.client.loadUserPersistedValues(\n    user: StatsigUser,\n  idType: string, // userID, stableID, customIDxyz, etc\n)\n"})}),(0,s.jsxs)(t.p,{children:["Putting it all together, assuming you have implemented the ",(0,s.jsx)(t.code,{children:"UserPersistentStorageInterface"})," and set it on ",(0,s.jsx)(t.code,{children:"StatsigOptions"}),", your call site will look like this:"]}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-kotlin",children:'// Asynchronous \nval callback = object: IPersistentStorageCallback {\n    @override\n    fun onLoaded(values: PersistedValues) {\n        Statsig.getExperiment(user, "sample_experiment", GetExperimentOptions(userPersistedValues = values))\n    }\n}\nval userValues = Statsig.client.loadUserPersistedValuesAsync(user, "userID", callback)\n\n// Synchronous\nval user = StatsigUser(userID = "user123")\nval userValues = Statsig.client.loadUserPersistedValues(user, \'userID\');\nconst experiment = statsig.getExperiment({userID: "123"}, \'the_allocated_experiment\', { userPersistedValues: userValues });\n'})}),(0,s.jsx)(t.p,{children:"If you are using java, you can only override loadAsync function and ignore load function as empty."})]}),(0,s.jsxs)(i.A,{value:"js-mono-on-device",children:[(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const storage = new CustomStorageAdapter(); // Need to implement\nconst adapter = new UserPersistentOverrideAdapter(storage);\nconst client = new StatsigOnDeviceEvalClient(\n  'client-key', \n  { overrideAdapter: adapter }\n);\nawait client.initializeAsync();\n\nconst userInControl = { userID: \"123\" }\nconst userInUnknown = { userID: \"unknown\" }\nconst userPersistedValues = adapter.loadUserPersistedValues(user, 'userID');\n\nlet experiment = client.getExperiment('active_experiment', user, { userPersistedValues });\nconsole.log(experiment.getGroupName()) // 'Control'\n\nexperiment = client.getExperiment('active_experiment', userInUnknown, { userPersistedValues });\nconsole.log(experiment.getGroupName()) // 'Control'\n"})}),(0,s.jsxs)(t.p,{children:["For a full implementation example, you can refer to our ",(0,s.jsx)(t.a,{href:"https://github.com/statsig-io/js-client-monorepo/tree/main/samples/next-js/src/app/persisted-user-storage-example-on-device",children:"Persistent Storage On-Device Eval Example"})," in Next.js."]})]}),(0,s.jsx)(i.A,{value:"legacy-js",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"await statsig.initialize(\n  'client-key',\n  { userPersistentStorage: new CustomStorageAdapter() } // Need to implement\n);\n\nconst userInControl = { userID: \"123\" }\nconst userInUnknown = { userID: \"unknown\" }\nconst userPersistedValues = await statsig.loadUserPersistedValuesAsync(userInControl, 'userID');\n\nlet experiment = statsig.getExperiment(userInControl, 'active_experiment', { userPersistedValues });\nconsole.log(experiment.getGroupName()) // 'Control'\n\nexperiment = statsig.getExperiment(userInUnknown, 'active_experiment', { userPersistedValues });\nconsole.log(experiment.getGroupName()) // 'Control'\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"support-in-ios-and-android-sdks",children:"Support in iOS and Android SDKs"}),"\n",(0,s.jsxs)(t.p,{children:["Android and iOS SDKs offer a simplified version of Persistent Storage called ",(0,s.jsx)(t.code,{children:"keepDeviceValues"})," that relies on on-device storage. While this is less flexible its simple to leverage - with a simple boolean flag. When enabled, the SDK (under the hood in the getExperiment/getLayer call) will check for previous stored value, and use those instead, even if allocation or targeting has changed. When the experiment ends - the SDK will stop persisting values."]}),"\n",(0,s.jsxs)(a.A,{defaultValue:"ios",values:[{label:"iOS",value:"ios"},{label:"Android",value:"android"}],children:[(0,s.jsxs)(i.A,{value:"ios",children:[(0,s.jsx)(t.h4,{id:"swift",children:"Swift:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-swift",children:'// With an Experiment:\nlet titleExperiment = Statsig.getExperiment("new_user_promo_title", true) // <-- "true" flag sets keep device values\n// Use the experiment like normal:\nlet promoTitle = titleExperiment.getValue(forKey: "title", defaultValue: "Welcome to Statsig!")\n\n// Or a Layer:\nlet layer = Statsig.getLayer("user_promo_experiments", true) // <-- "true" flag sets keep device values\n// Use the layer like normal:\nlet promoTitle = layer.getValue(forKey: "title", defaultValue: "Welcome to Statsig!")\n'})}),(0,s.jsx)(t.h4,{id:"objective-c",children:"Objective C:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-objc",children:'// With an Experiment:\nDynamicConfig *expConfig = [Statsig getExperimentForName:@"new_user_promo_title" true]; // <-- "true" flag sets keep device values\n// Use the experiment like normal:\nNSString *promoTitle = [expConfig getStringForKey:@"title" defaultValue:@"Welcome to Statsig! Use discount code WELCOME10OFF for 10% off your first purchase!"];\ndouble discount = [expConfig getDoubleForKey:@"discount" defaultValue:0.1];\n\ndouble price = msrp * (1 - discount);\n'})})]}),(0,s.jsxs)(i.A,{value:"android",children:[(0,s.jsx)(t.h4,{id:"java",children:"Java:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Java",children:'// With an Experiment:\nDynamicConfig titleExperiment = Statsig.getExperiment("new_user_promo_title", true); // <-- "true" flag sets keep device values\n// Use the experiment like normal:\nString promoTitle = titleExperiment.getString("title", "Welcome to Statsig!");\n\n// Or a Layer:\nLayer layer = Statsig.getLayer("user_promo_experiments", true) // <-- "true" flag sets keep device values\n// Use the layer like normal:\nString promoTitle = layer.getString("title", "Welcome to Statsig!");\n'})}),(0,s.jsx)(t.h4,{id:"kotlin",children:"Kotlin:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-kotlin",children:'// With an Experiment:\nval titleExperiment = Statsig.getExperiment("new_user_promo_title", true) // <-- "true" flag sets keep device values\n// Use the experiment like normal:\nval promoTitle = titleExperiment.getString("title", "Welcome to Statsig!")\n\n// Or a Layer:\nval layer = Statsig.getLayer("user_promo_experiments", true) // <-- "true" flag sets keep device values\n// Use the layer like normal:\nval promoTitle = layer.getString("title", "Welcome to Statsig!")\n\n'})})]})]})]})}function g(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},19365:(e,t,n)=>{n.d(t,{A:()=>i});n(96540);var s=n(34164);const r={tabItem:"tabItem_Ymn6"};var a=n(74848);function i(e){let{children:t,hidden:n,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,i),hidden:n,children:t})}},11470:(e,t,n)=>{n.d(t,{A:()=>b});var s=n(96540),r=n(34164),a=n(23104),i=n(56347),l=n(205),o=n(57485),c=n(31682),u=n(70679);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:r}}=e;return{value:t,label:n,attributes:s,default:r}}))}(n);return function(e){const t=(0,c.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function g(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const r=(0,i.W6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,o.aZ)(a),(0,s.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(r.location.search);t.set(a,e),r.replace({...r.location,search:t.toString()})}),[a,r])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,a=p(e),[i,o]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:a}))),[c,d]=h({queryString:n,groupId:r}),[m,v]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,a]=(0,u.Dv)(n);return[r,(0,s.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:r}),x=(()=>{const e=c??m;return g({value:e,tabValues:a})?e:null})();(0,l.A)((()=>{x&&o(x)}),[x]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!g({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);o(e),d(e),v(e)}),[d,v,a]),tabValues:a}}var v=n(92303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=n(74848);function j(e){let{className:t,block:n,selectedValue:s,selectValue:i,tabValues:l}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),u=e=>{const t=e.currentTarget,n=o.indexOf(t),r=l[n].value;r!==s&&(c(t),i(r))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{const n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1];break}}t?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},t),children:l.map((e=>{let{value:t,label:n,attributes:a}=e;return(0,f.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>o.push(e),onKeyDown:d,onClick:u,...a,className:(0,r.A)("tabs__item",x.tabItem,a?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function S(e){const t=m(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",x.tabList),children:[(0,f.jsx)(j,{...t,...e}),(0,f.jsx)(y,{...t,...e})]})}function b(e){const t=(0,v.A)();return(0,f.jsx)(S,{...e,children:d(e.children)},String(t))}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var s=n(96540);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);