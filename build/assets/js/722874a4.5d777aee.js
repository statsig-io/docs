"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[3032],{22249:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var s=n(74848),a=n(28453);const i={title:"How Evaluation Works",slug:"/sdks/how-evaluation-works"},o=void 0,r={id:"sdks/how-evaluation-works",title:"How Evaluation Works",description:"Evaluation\u2019s importance",source:"@site/docs/sdks/how-evaluation-works.mdx",sourceDirName:"sdks",slug:"/sdks/how-evaluation-works",permalink:"/sdks/how-evaluation-works",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/sdks/how-evaluation-works.mdx",tags:[],version:"current",lastUpdatedAt:175701833e4,frontMatter:{title:"How Evaluation Works",slug:"/sdks/how-evaluation-works"},sidebar:"api",previous:{title:"Initializing the SDK",permalink:"/client/concepts/initialize"},next:{title:"Debugging",permalink:"/sdk/debugging"}},l={},u=[{value:"Evaluation\u2019s importance",id:"evaluations-importance",level:2},{value:"How Evaluation Works",id:"how-evaluation-works",level:2},{value:"When Evaluation Happens",id:"when-evaluation-happens",level:2},{value:"What this means:",id:"what-this-means",level:2},{value:"Evaluation of null/empty unitIDs",id:"evaluation-of-nullempty-unitids",level:2}];function h(e){const t={a:"a",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"evaluations-importance",children:"Evaluation\u2019s importance"}),"\n",(0,s.jsx)(t.p,{children:"The essential function of the Statsig SDKs is reliable, consistent, incredibly performant allocation of users to the correct bucket in your experiment or feature gate. Understanding how we accomplish this can help you answer questions like:\nWhy do I have to pass every user attribute, every time?\nWhy do I have to wait for initialization to complete?\nWhen do you decide each users\u2019 bucket?"}),"\n",(0,s.jsx)(t.h2,{id:"how-evaluation-works",children:"How Evaluation Works"}),"\n",(0,s.jsx)(t.p,{children:"Evaluation in Statsig is deterministic. Given the same user object and the same state of the experiment or feature gate, Statsig always returns the same result, even when evaluated on different platforms (client or server). Here's how it works:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Salt Creation"}),": Each experiment or feature gate rule generates a unique salt."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Hashing"}),": The user identifier (e.g., userId, organizationId) is passed through a SHA256 hashing function, combined with the salt, which produces a large integer."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Bucket Assignment"}),": The large integer is then subjected to a modulus operation with 10000 (or 1000 for layers), assigning the user to a bucket."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Bucket Determination"}),": The result defines the specific bucket out of 10000 (or 1000 for layers) where the user is placed."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["This process ensures a randomized but deterministic bucketing of users across different experiments or feature gates. The unique salt per-experiment or feature gate rule ensures that the same user can be assigned to different buckets in different experiments. This also means that if you rollout a feature gate rule to 50% - then back to 0% - then back to 50%, the same 50% of users will be re-exposed, ",(0,s.jsx)(t.strong,{children:"so long as you reuse the same rule"})," - and not create a new one. See ",(0,s.jsx)(t.a,{href:"/faq/#when-i-change-the-rollout-percentage-of-a-rule-on-a-feature-gate-will-users-who-passed-continue-to-pass",children:"here"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For more details, check our open-source SDKs ",(0,s.jsx)(t.a,{href:"https://github.com/statsig-io/node-js-server-sdk/blob/main/src/Evaluator.ts",children:"here"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"This is not generally recommended, but for advanced use cases - e.g. a series of related experiments that needs to reuse the control and test buckets, we now expose the ability to copy and set the salts used for deterministic hashing. This is meant to be used with care and is only available to Project Administrators. It is available in the Overflow (...) menu in Experiments."}),"\n",(0,s.jsx)(t.h2,{id:"when-evaluation-happens",children:"When Evaluation Happens"}),"\n",(0,s.jsx)(t.p,{children:"Evaluation happens when the gate or experiment is checked on Server SDKs. To be able to do this, Server SDKs hold the entire ruleset of your project in memory - a representation of each gate or experiment in JSON. On client SDKs, we evaluate all of the gates/experiments when you call initialize - on our servers."}),"\n",(0,s.jsx)(t.p,{children:"All of the above logic holds true for both SDKs. In both, the user\u2019s assignment bucket is not sent to Statsig until you call the getExperiment/checkGate method in the SDK."}),"\n",(0,s.jsx)(t.h2,{id:"what-this-means",children:"What this means:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Performant Evaluation:"})," no evaluations require a network request, and we focus on evaluation performance, meaning that checks take <1ms after evaluation."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"The SDKs don\u2019t \u201cremember\u201d user attributes, or previous evaluations:"})," we rely on you to pass all of the necessary user attributes consistently - and we promise if you do, we\u2019ll provide the same value.\nA common assumption is that Statsig tracks of a list of all ids and what group they were assigned to for experiments/gates. While our data pipelines track users exposed to each variant to compute experiment results, we do not cache previous evaluations and maintain distributed evaluation state across client and server SDKs. That won't scale - we've even talked to customers doing this in the past, and were paying more for Redis to maintain that state than they ended up paying for Statsig."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Server SDKs can handle multiple users:"})," because they hold the ruleset in memory, Server SDKs can evaluate any user. Without a network request. This means you\u2019ll have to pass a user object into the getExperiment method on Server SDKs, whereas on client SDKs you pass it into initialize()."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"We ensure each user receives the same bucket:"})," our ID-based hashing assignment guarantees consistency. If you make a change in console that could affect user bucketing on an experiment, we\u2019ll provide warning."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"evaluation-of-nullempty-unitids",children:"Evaluation of null/empty unitIDs"}),"\n",(0,s.jsx)(t.p,{children:"Note, we do not apply any filtering/ business logic before we assign an individual userID. This means that even a null or empty unitID will be bucketed depending on the salt."})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(96540);const a={},i=s.createContext(a);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);