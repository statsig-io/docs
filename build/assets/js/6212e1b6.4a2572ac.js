"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[90824],{27699:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var s=a(74848),n=a(28453);const r={title:"Loading Pulse",slug:"/statsig-warehouse-native/features/reloads",sidebar_label:"Loading Pulse",keywords:["owner:vm"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},o=void 0,i={id:"statsig-warehouse-native/features/reloads",title:"Loading Pulse",description:"The Pulse Engine",source:"@site/docs/statsig-warehouse-native/features/reloads.md",sourceDirName:"statsig-warehouse-native/features",slug:"/statsig-warehouse-native/features/reloads",permalink:"/statsig-warehouse-native/features/reloads",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/statsig-warehouse-native/features/reloads.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Loading Pulse",slug:"/statsig-warehouse-native/features/reloads",sidebar_label:"Loading Pulse",keywords:["owner:vm"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"warehouse",previous:{title:"Quality Score",permalink:"/experimentation/quality-score-whn"},next:{title:"Turbo Mode",permalink:"/statsig-warehouse-native/features/turbo"}},l={},d=[{value:"The Pulse Engine",id:"the-pulse-engine",level:2},{value:"Types of Reloads",id:"types-of-reloads",level:3},{value:"Transparency",id:"transparency",level:3},{value:"Efficient Reloads",id:"efficient-reloads",level:3},{value:"Cleaning Up Storage",id:"cleaning-up-storage",level:3}];function u(e){const t={a:"a",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"the-pulse-engine",children:"The Pulse Engine"}),"\n",(0,s.jsx)(t.p,{children:"Statsig's experimentation engine runs the necessary setup, diagnostics, and transformations required to generate the data points that power statistical experiment analysis. In Warehouse Native, this consists of a series of query jobs (referred to as a DAG, or Directed Acyclic Graph) that take data from your sources and metric configurations to a final result set."}),"\n",(0,s.jsxs)(t.p,{children:["Controls for reloads are available on the pulse results page:\n",(0,s.jsx)(t.img,{src:"https://github.com/statsig-io/docs/assets/102695539/f6c1aa47-8d6e-4b21-96ac-f2281d0d0491",alt:"Pulse Load Controls"})]}),"\n",(0,s.jsx)(t.h3,{id:"types-of-reloads",children:"Types of Reloads"}),"\n",(0,s.jsx)(t.p,{children:"Statsig offers a number of ways to reload data:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/statsig-warehouse-native/features/full-reloads",children:"Full Reloads"})," completely restate your experiment data. This can be useful if your underlying data changes a lot (e.g. a full DBT reload) day-to-day, and you want to ensure your analysis matches your raw data"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/statsig-warehouse-native/features/incremental-reloads",children:"Incremental Reloads"})," catch your data up from where it was the last load to where it is today. Running daily incremental reloads is the recommended way to keep your data current without using unnecessary compute resources to recalculate data that hasn't changed."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/statsig-warehouse-native/features/metric-reloads",children:"Metric Reloads"})," are a useful feature for when you want to add a metric to an analysis, or when a metric definition has changed. This does an efficient spot replacement of the data for a single metric or set of metrics."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Full and incremental loads can be ",(0,s.jsx)(t.a,{href:"/statsig-warehouse-native/connecting-your-warehouse/scheduled-reloads/",children:"scheduled"})," so that you have fresh results each day."]}),"\n",(0,s.jsx)(t.h3,{id:"transparency",children:"Transparency"}),"\n",(0,s.jsx)(t.p,{children:"For every load, Statsig logs the compute time and jobs, cost, and queries associated with the reload. This is highly visible in your console, and provides a powerful tool for understanding what's taking time or delaying results."}),"\n",(0,s.jsx)(t.h3,{id:"efficient-reloads",children:"Efficient Reloads"}),"\n",(0,s.jsx)(t.p,{children:"Statsig borrows heavily from its cloud roots to optimize the queries running in your warehouse - generally, in head-to-head evaluations customers report that we use significantly less resources than comparable platforms."}),"\n",(0,s.jsx)(t.p,{children:"To add to this, Statsig offers turbo mode, which skips some enrichment calculations (in particular some time series rollups) in order to very cheaply compute the latest snapshot of your data. With this tool, customers have run experiments on 150+ million users in less than 5 minutes on a snowflake S cluster."}),"\n",(0,s.jsx)(t.h3,{id:"cleaning-up-storage",children:"Cleaning Up Storage"}),"\n",(0,s.jsx)(t.p,{children:"Statsig will automatically clean up after itself for explore datasets, power analyses, and stratification artifacts. Once you make a decision on an experiment, you can choose whether or not to delete the staging datasets and/or the result datasets; you can always come back to the experiment to clean up from the experiment menu as well."})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>i});var s=a(96540);const n={},r=s.createContext(n);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);