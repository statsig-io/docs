"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[42961],{96139:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>u});var o=n(74848),i=n(28453);const s={title:"Contextual Bandit (Autotune AI)",sidebar_label:"Contextual Bandit",slug:"/autotune/contextual/introduction",keywords:["owner:vm"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},a=void 0,r={id:"autotune/contextual/introduction",title:"Contextual Bandit (Autotune AI)",description:"Contextual Multi-Armed Bandits are a subset of Multi-Armed-Bandits which use context about a user to personalize their experience. This is generally achieved by predicting outcomes from among the variants, and picking the best outcome while factoring for uncertainty. Specifically, they will tend to prefer a slightly worse prediction that has a lot of uncertainty, thereby exploring that variant.",source:"@site/docs/autotune/contextual/introduction.md",sourceDirName:"autotune/contextual",slug:"/autotune/contextual/introduction",permalink:"/autotune/contextual/introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/autotune/contextual/introduction.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Contextual Bandit (Autotune AI)",sidebar_label:"Contextual Bandit",slug:"/autotune/contextual/introduction",keywords:["owner:vm"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"cloud",previous:{title:"Methodology",permalink:"/multi-armed-bandit"},next:{title:"Getting Started",permalink:"/autotune/contextual/getting-started"}},l={},u=[{value:"Use Cases",id:"use-cases",level:2},{value:"Methodology",id:"methodology",level:2},{value:"Drawbacks",id:"drawbacks",level:2},{value:"Outcome Types",id:"outcome-types",level:2},{value:"Training",id:"training",level:2},{value:"SDK Support",id:"sdk-support",level:2}];function c(e){const t={a:"a",admonition:"admonition",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Contextual Multi-Armed Bandits are a subset of Multi-Armed-Bandits which use context about a user to personalize their experience. This is generally achieved by predicting outcomes from among the variants, and picking the best outcome while factoring for uncertainty. Specifically, they will tend to prefer a slightly worse prediction that has a lot of uncertainty, thereby exploring that variant."}),"\n",(0,o.jsx)(t.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsx)(t.p,{children:"Contextual bandits bridge the gap between un-personalized solutions and fully fledged ranking solutions. The main limitation is that contextual bandits:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Have a fixed output set of variants they can show"}),"\n",(0,o.jsx)(t.li,{children:'Have limited ability to account for complex context on the "object" being seen/predict for novel content (e.g. video ranking)'}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"At the same time, their simplicity comes with advantages. Statsig's Autotune AI evaluates in near-real-time on both the server and client, taking a few milliseconds or less to return the ideal experience for a given user context. They're also simple to set up and test; you can set up a test in less than an hour, start getting model results the next hour, and start to see experiment results the next in the Statsig console."}),"\n",(0,o.jsxs)(t.p,{children:["See our ",(0,o.jsx)(t.a,{href:"https://www.statsig.com/blog/statsig-autotune-contextual-bandits-personalization",children:"blog"})," for more discussion on use cases and motivations."]}),"\n",(0,o.jsx)(t.h2,{id:"methodology",children:"Methodology"}),"\n",(0,o.jsxs)(t.p,{children:["Statsig's autotune AI uses a LinUCB based approach. We think this paper is a good introduction to the topic: ",(0,o.jsx)(t.a,{href:"https://arxiv.org/pdf/1003.0146",children:"Li, Chu, Langford, Schapire"}),". For coverage of regret analysis, we think these lecture notes from ",(0,o.jsx)(t.a,{href:"https://courses.cs.washington.edu/courses/cse599i/18wi/resources/lecture10/lecture10.pdf",children:"Jain from the University of Washington"})," are a useful resource."]}),"\n",(0,o.jsx)(t.p,{children:"Autotune AI works with categorical and numerical features. Whatever key-value pairs attached to the custom object on the Statsig user will be converted into categorical/numerical features based on their data type. Categorical features will be one-hot-encoded. You should not need to build complex training pipelines, though many customers will pass pre-evaluated user attributes or predictions as context objects."}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["There is support for specifying features up front in Statsig's console. This can be helpful for you to know what features you need to fetch for the bandit in cases that there's an expensive/live lookup. For warehouse native customers, there is planned work around allowing you to join entity properties during the analysis phase so that you can plug in your own feature store to autotune AI analysis, similar to our approach with ",(0,o.jsx)(t.a,{href:"/experiments-plus/cure",children:"CURE"}),"."]})}),"\n",(0,o.jsx)(t.p,{children:"Algorithmically, we will choose the best model (e.g. Ridge, Logistic regressions) under the hood based on your data types and performance, and generate a model from your data. The estimated standard error of the model is used to generate a prediction confidence interval. During evaluation, user context is used to predict an outcome for each Variant, and the corresponding confidence interval is applied to that prediction. The best variant is chosen as the one with the highest upper end of a 95% confidence interval. This interval size can be tuned by modifying the exploration parameter in the Autotune setup page."}),"\n",(0,o.jsxs)(t.p,{children:["For deeper discussion, please view the ",(0,o.jsx)(t.a,{href:"/autotune/contextual/methodology",children:"Methodology"})," page."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["You can also fetch a ranked list from Statsig and then manually expose those you show to the user, for use cases where you have client-side filtering or want to show multiple options; see ",(0,o.jsx)(t.a,{href:"/using-bandits",children:"Advanced Usage"})]})}),"\n",(0,o.jsx)(t.h2,{id:"drawbacks",children:"Drawbacks"}),"\n",(0,o.jsx)(t.p,{children:"Because Statsig manages the models, we cannot guarantee perfect tuning of models, or provide more advanced models like Neural Networks. This means that if recommendations are a critical business problem for your team, this feature can be a stepping stone but is not an appropriate end-state solution."}),"\n",(0,o.jsx)(t.p,{children:"In terms of approach, we believe our approach offers a good balance of simplicity, speed, and regret; but if you have specific use cases in mind (e.g. real-time updates) they may not be fully served by the current approach."}),"\n",(0,o.jsx)(t.p,{children:'Lastly, given our models generally assume linearity, we may not be able to capture complex user interactions; this is best for broad-strokes effects, though feature interactions terms can generate decent power in cases of "if-and-then" relationships between predictors and outcomes.'}),"\n",(0,o.jsx)(t.h2,{id:"outcome-types",children:"Outcome Types"}),"\n",(0,o.jsx)(t.p,{children:'Autotune AI has a few different model types under the hood - this means it can be used for both classification use cases (will this user click a button) and for continuous outcomes (how much time will the user spend reading articles). This means that you can optimize for both "outcomes" and "metrics"; additionally, you can toggle off higher is better for metrics to try to drive down an outcome like latency.'}),"\n",(0,o.jsx)(t.p,{children:"For classification cases, Autotune AI will identify if any outcome occurs within its attribution window. For continuous cases, Autotune AI requires an event name and field name, and will use the numerical value associated with that field."}),"\n",(0,o.jsx)(t.h2,{id:"training",children:"Training"}),"\n",(0,o.jsx)(t.p,{children:"Training pipelines are run hourly."}),"\n",(0,o.jsx)(t.p,{children:"For Warehouse Native customers, data is processed in your warehouse, and an anonymized feature set is used to train the models. Exposures will be exported on-demand for each load up to the first million, and in daily batches thereafter. Log events sent to statsig are exported hourly if you are using statsig to log outcomes, or you can plug into metric sources from your warehouse for outcome tracking."}),"\n",(0,o.jsx)(t.p,{children:"For cloud customers, the data is processed and trained entirely in Statsig's servers."}),"\n",(0,o.jsx)(t.h2,{id:"sdk-support",children:"SDK Support"}),"\n",(0,o.jsx)(t.p,{children:"Statsig supports contextual autotune in all Client SDKs, but only in the following server SDKs:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/server-core/node-core",children:"Node"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/server-core/python-core",children:"Python"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/server-core/java-core",children:"Java"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/server-core/elixir-core",children:"Elixir"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"/server-core/rust-core",children:"Rust"})}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"/server/golangSDK",children:"Go"})," v1.39.0+"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"/server/rubySDK",children:"Ruby"})," v2.4.0+"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(96540);const i={},s=o.createContext(i);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);