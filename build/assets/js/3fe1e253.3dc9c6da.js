"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[19295],{89205:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(74848),a=n(28453);const r={title:"Best practices for Feature Gates",sidebar_label:"Best practices",slug:"/feature-flags/best-practices",keywords:["owner:shubham"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},i=void 0,o={id:"feature-flags/best-practices",title:"Best practices for Feature Gates",description:"Statsig classifies the best practices for using feature gates into four categories: implementation, development, collaboration, and governance.",source:"@site/docs/feature-flags/best-practices.md",sourceDirName:"feature-flags",slug:"/feature-flags/best-practices",permalink:"/feature-flags/best-practices",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/feature-flags/best-practices.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Best practices for Feature Gates",sidebar_label:"Best practices",slug:"/feature-flags/best-practices",keywords:["owner:shubham"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"cloud",previous:{title:"Permanent and stale gates",permalink:"/feature-flags/permanent-and-stale-gates"},next:{title:"Overview",permalink:"/dynamic-config"}},l={},c=[{value:"Implementation",id:"implementation",level:2},{value:"Development",id:"development",level:2},{value:"Collaboration",id:"collaboration",level:2},{value:"Governance",id:"governance",level:2}];function d(e){const t={h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Statsig classifies the best practices for using feature gates into four categories: implementation, development, collaboration, and governance."}),"\n",(0,s.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Manage for ease and maintainability"})," \u2013 Use simple if/else gate checks for short lived gates that you can quickly clean up after the release. Use configuration parameters for longer lived gates to avoid nesting multiple gates and growing complexity in your code over time."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Select the gating decision point"})," \u2013 Implement client-side feature gates to select users where most context is available and/or when the feature is primarily developed in the presentation layer (e.g. user registration flow). Implement server-side feature gates when most context is available with the application server and/or when the feature is primarily related to backend system behavior (e.g. new cache layer for better performance). Localizing these gating decisions within the service whose behavior is being changed is the best option in these cases."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Focus on one feature"})," \u2013 Using one feature gate to control multiple features at a time can be confusing and can make troubleshooting issues difficult. If there are multiple parts of a feature that must work together, create a master feature gate to control child feature gates for these individual parts."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"development",children:"Development"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Speed up development"})," \u2013 Shipping new functionality behind a feature gate ensures that the code path is not activated until you\u2019re ready to integrate with your dependencies. This enables you to ship service components faster without being blocked by any dependencies."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Always be testing"})," - Use feature gates to ensure that in-development features remain inactive in production while continuing to test new functionality in staging or pre-production environments."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Progressive delivery"})," \u2013 Ship code for in-development features early and often. Shipping code as part of the main branch that can be deployed to production at any time avoids painful merging of long-lived branches at a later point."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Validate functionality with trusted users"})," \u2013 Use features gates to only expose new functionality to trusted and friendly users such as teammates, company employees, and beta customers before launching publicly. Verify that the new functionality is working as expected."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Set up a phased canary release"})," \u2013 Use feature gates to progressively expose new functionality to a small percentage of users, validate user experience, and monitor production system health before launching broadly. In the initial stages, scale up slowly. We recommend the following rollout strategy, which increases by the same multiplier each time, increasing the bucket of new users exposed to the experiment by a larger margin each time: 0% -> 2% -> 10% -> 50% -> 100%"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Validate user and system impact"})," - Compare key user and system metrics against the default behavior. Common user metrics to test include daily and weekly active users, weekly retention, and conversion rates for key user actions. Common system metrics include error response rates, application crash rates, p50/p90/p99 request-response latency, and CPU utilization. You can create a metric for any key user or system behavior by logging the event that best proxies that behavior with Statsig."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Ramp up or roll back"})," \u2013 Identify issues, and negative impact on users early. Use metric-based evidence to decide whether to release the feature more broadly. If you decide to launch, ramp up deployment (e.g. 10% -> 50% -> 100%)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Clean-up after releases"})," \u2013 Once the release is complete, remove unnecessary gates from code. Once they are no longer checked, you are free to turn them off/delete them."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"collaboration",children:"Collaboration"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Scoped Access - Invite verified teammates to create, review, and approve feature gates for a specific project."}),"\n",(0,s.jsx)(t.li,{children:"Role-based Access Control (RBAC) - Ensure that only project members with the appropriate privileges can create and edit feature gate configurations with role-based access control."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"governance",children:"Governance"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Audit and record"})," - Set up audit logs for any changes that your team makes to any feature gates."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Monitor and automate"})," - Set up automated health monitoring and alerts to improve visibility of your feature gates, reduce response times for any issues, and create automated workflows for common response patterns."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(96540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);