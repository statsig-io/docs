"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[31629],{56825:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=i(74848),n=i(28453);const a={title:"Log Metrics",sidebar_label:"Log",keywords:["owner:vm"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},o=void 0,r={id:"statsig-warehouse-native/metrics/log",title:"Log Metrics",description:"Summary",source:"@site/docs/statsig-warehouse-native/metrics/log.md",sourceDirName:"statsig-warehouse-native/metrics",slug:"/statsig-warehouse-native/metrics/log",permalink:"/statsig-warehouse-native/metrics/log",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/statsig-warehouse-native/metrics/log.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Log Metrics",sidebar_label:"Log",keywords:["owner:vm"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"warehouse",previous:{title:"Percentile",permalink:"/statsig-warehouse-native/metrics/percentile"},next:{title:"First/Latest Value",permalink:"/statsig-warehouse-native/metrics/latest-value"}},l={},c=[{value:"Summary",id:"summary",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"Calculation",id:"calculation",level:2},{value:"Methodology Notes",id:"methodology-notes",level:3},{value:"Options",id:"options",level:2}];function u(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(t.p,{children:["Log metrics are a special case of ",(0,s.jsx)(t.a,{href:"./sum",children:"Sum"})," and ",(0,s.jsx)(t.a,{href:"./count",children:"Count"})," metrics, where the unit-level metric value is logged before calculating pulse results. This can be configured in the advanced settings of Sum or Count metrics."]}),"\n",(0,s.jsx)(t.p,{children:"This defaults to taking the natural log, but a custom base can be specified."}),"\n",(0,s.jsx)(t.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,s.jsx)(t.p,{children:"This can be useful for understanding if the distribution of a log-normal or tail-driven metric has shifted. This is calculated as a conditional mean - implicitly, it is a ratio metric where the numerator is the sum of unit-level log values, and the denominator is a 1 for units with a valid log. Records with a 0 denominator are accordingly filtered out."}),"\n",(0,s.jsx)(t.p,{children:"This is done because imputing 0s for logs does not work without a treatment such as an inverse hyperbolic sine function."}),"\n",(0,s.jsx)(t.p,{children:"This might be revenue, time spent, or some other metric where a small portion of users drives most of the metric value, but it's important to drive \"bulk\" improvements. Log metrics can be thought of as measuring relative change per unit, since an increase of 1 corresponds to a multiplication by the log's base."}),"\n",(0,s.jsx)(t.h2,{id:"calculation",children:"Calculation"}),"\n",(0,s.jsxs)(t.p,{children:["At the unit level, count metrics run a COUNT(1) or SUM(",(0,s.jsx)(t.code,{children:"value"}),") across their metric source."]}),"\n",(0,s.jsx)(t.p,{children:"At the group level, the mean is calculated as the SUM of the log of the unit-level value, divided by the count of units with a unit-level value that log is valid for (exists, and is greater than 0)."}),"\n",(0,s.jsx)(t.p,{children:"This would look like the SQL below, for a count metric:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'-- Unit Level\nSELECT\n  source_data.unit_id,\n  exposure_data.group_id,\n  COUNT(1) as value\nFROM source_data\nJOIN exposure_data\nON\n  -- Only include users who saw the experiment\n  source_data.unit_id = exposure_data.unit_id\n  -- Only include data from after the user saw the experiment\n  -- In this case exposure_data is already deduped to the "first exposure"\n  AND source_data.timestamp >= exposure_data.timestamp\nGROUP BY unit_id, group_id;\n\n-- Group Level\nSELECT\n  group_id,\n  -- divide the sum of the logged values by the count of participating units\n  SUM(LOG(value, <base>))/COUNT(1) as mean\nFROM unit_data\nWHERE value > 0\n-- the filter is implicit from the CTE, but let\'s make it explicit\n-- a sum metric might have negative values\nGROUP BY group_id;\n'})}),"\n",(0,s.jsx)(t.h3,{id:"methodology-notes",children:"Methodology Notes"}),"\n",(0,s.jsx)(t.p,{children:"Log metrics can be tricky to interpret and to extrapolate out to topline values. We highly encourage you to use this in conjunction with the raw or winsorized SUM and COUNT metric."}),"\n",(0,s.jsxs)(t.p,{children:["There's a few ways to handle 0s in a log metric; a transformation like ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions",children:"IHS"})," can approximate the behavior of log for large values while accepting 0s as inputs, or you can scope the analysis to non-zero units. We've chosen the second for ease of interpretation (log properties are broadly understood)."]}),"\n",(0,s.jsxs)(t.p,{children:["This does mean there's potentially a confounding factor of participation rate; to mitigate this, results are presented the same as for ",(0,s.jsx)(t.a,{href:"/statsig-warehouse-native/metrics/ratio",children:"ratio"})," metrics and present statistics for the overall result as well as the implicit numerators and denominators."]}),"\n",(0,s.jsx)(t.h2,{id:"options",children:"Options"}),"\n",(0,s.jsx)(t.p,{children:"Non-log options will be based on whether or not the metric is a Sum or Count."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Custom log Base","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"You can configure a custom base for the log operation. Defaults to LN"}),"\n"]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var s=i(96540);const n={},a=s.createContext(n);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);