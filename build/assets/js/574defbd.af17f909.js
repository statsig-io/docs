"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[69124],{33381:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>o});var n=i(74848),r=i(28453);const t={title:"Count Distinct Metrics",sidebar_label:"Count Distinct Metrics",slug:"/metrics/count_distinct_metric_type",keywords:["owner:Aamodit"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},l="Count Distinct Metrics",a={id:"metrics/count-distinct",title:"Count Distinct Metrics",description:"Purpose of count_distinct",source:"@site/docs/metrics/count-distinct.md",sourceDirName:"metrics",slug:"/metrics/count_distinct_metric_type",permalink:"/metrics/count_distinct_metric_type",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/metrics/count-distinct.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Count Distinct Metrics",sidebar_label:"Count Distinct Metrics",slug:"/metrics/count_distinct_metric_type",keywords:["owner:Aamodit"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"cloud",previous:{title:"Funnel Metrics",permalink:"/metrics/create-user-funnels"},next:{title:"Verified Metrics",permalink:"/metrics/verified"}},c={},o=[{value:"Purpose of count_distinct",id:"purpose-of-count_distinct",level:2},{value:"For context, what are sketches?",id:"for-context-what-are-sketches",level:2},{value:"Core Principles of HLL++",id:"core-principles-of-hll",level:2},{value:"Precision, Memory, and Error Relationship",id:"precision-memory-and-error-relationship",level:2},{value:"Error Behavior Over Cardinality",id:"error-behavior-over-cardinality",level:2},{value:"Example for p = 15 (m = 32,768)",id:"example-for-p--15-m--32768",level:3},{value:"Merging Sketches Over Time or Partitions",id:"merging-sketches-over-time-or-partitions",level:2},{value:"Mathematical Formulation",id:"mathematical-formulation",level:2},{value:"Best Practices and Limitations",id:"best-practices-and-limitations",level:2},{value:"Conclusion and Recommendations",id:"conclusion-and-recommendations",level:2},{value:"Choosing Precision for Your Cardinality",id:"choosing-precision-for-your-cardinality",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Defaults at Statsig",id:"defaults-at-statsig",level:2}];function d(e){const s={admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",msup:"msup",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"count-distinct-metrics",children:"Count Distinct Metrics"})}),"\n",(0,n.jsx)(s.h2,{id:"purpose-of-count_distinct",children:"Purpose of count_distinct"}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.code,{children:"count_distinct"})," metric reports the number of unique values in a dataset. Computing exact distinct counts at large scale requires storing all values or all hashes, which can be expensive in terms of memory and processing time. HyperLogLog++ (HLL++) sketches offer a probabilistic alternative that uses fixed or sublinear space to produce approximate distinct counts with a tight bound on relative error."]}),"\n",(0,n.jsx)(s.admonition,{type:"warning",children:(0,n.jsx)(s.p,{children:"Sketch-based count distinct metrics are in beta. Please reach out to learn more and join our beta testing!"})}),"\n",(0,n.jsx)(s.h2,{id:"for-context-what-are-sketches",children:"For context, what are sketches?"}),"\n",(0,n.jsx)(s.p,{children:'Sketches are a probabilistic summary of a large dataset that lets us answer certain queries "approximately" but very quickly and using little memory.  It does this all while using very little memory (often a fixed-size or sublinear footprint, like O(log n) or even constant space regardless of dataset size).'}),"\n",(0,n.jsx)(s.h2,{id:"core-principles-of-hll",children:"Core Principles of HLL++"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Hashing and Leading Zeros"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Each input is hashed uniformly into a 64-bit integer."}),"\n",(0,n.jsx)(s.li,{children:'The position of the first 1-bit in the hash (the "rank") provides an estimate of how many distinct items precede that hash in sorted order.'}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Register Array"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["The algorithm allocates ",(0,n.jsx)(s.em,{children:"m"})," registers, where ",(0,n.jsx)(s.em,{children:"m"})," = 2^p and ",(0,n.jsx)(s.em,{children:"p"})," is the precision parameter."]}),"\n",(0,n.jsx)(s.li,{children:"Each hashed value maps to one register. The register stores the maximum rank seen so far for values mapped to it."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Sparse and Dense Modes"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Sparse mode"})," is used when the number of distinct items is below 2^(p+5). It keeps an exact list of non-zero registers in a compact form. This yields near-zero error for small cardinalities."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Dense mode"})," is used when the count exceeds the sparse limit. The sketch is represented as a fixed array of ",(0,n.jsx)(s.em,{children:"m"})," registers, each one byte in size. Error increases slightly but remains tightly bounded."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Estimation and Bias Correction"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"The raw estimate is computed as the harmonic mean of 2^(\u2013register_value) across all registers, multiplied by a constant factor (alpha_m)."}),"\n",(0,n.jsx)(s.li,{children:"BigQuery applies empirical bias corrections and the HIP (historic inverse probability) estimator to reduce variance and worst-case error."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"precision-memory-and-error-relationship",children:"Precision, Memory, and Error Relationship"}),"\n",(0,n.jsxs)(s.p,{children:["The precision parameter ",(0,n.jsx)(s.em,{children:"p"})," controls the number of registers ",(0,n.jsx)(s.em,{children:"m"})," and thus the sketch's size and accuracy:"]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Precision p"}),(0,n.jsx)(s.th,{children:"Registers m = 2^p"}),(0,n.jsx)(s.th,{children:"Memory per Sketch"}),(0,n.jsx)(s.th,{children:"Approximate Relative Standard Error (1 sigma)"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"10"}),(0,n.jsx)(s.td,{children:"1,024"}),(0,n.jsx)(s.td,{children:"~1 KB"}),(0,n.jsx)(s.td,{children:"0.83 / sqrt(1,024) \u2248 2.6 %"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"12"}),(0,n.jsx)(s.td,{children:"4,096"}),(0,n.jsx)(s.td,{children:"~4 KB"}),(0,n.jsx)(s.td,{children:"0.83 / sqrt(4,096) \u2248 1.3 %"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"13"}),(0,n.jsx)(s.td,{children:"8,192"}),(0,n.jsx)(s.td,{children:"~8 KB"}),(0,n.jsx)(s.td,{children:"0.83 / sqrt(8,192) \u2248 0.92 %"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"15"}),(0,n.jsx)(s.td,{children:"32,768"}),(0,n.jsx)(s.td,{children:"~32 KB"}),(0,n.jsx)(s.td,{children:"0.83 / sqrt(32,768) \u2248 0.46 %"})]})]})]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Memory used grows linearly with ",(0,n.jsx)(s.em,{children:"m"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:["Error decreases as the inverse square root of ",(0,n.jsx)(s.em,{children:"m"}),"."]}),"\n",(0,n.jsx)(s.li,{children:"To halve the error, we must quadruple the number of registers."}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Examples of thresholds and steady\u2011state for common precisions:"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"p = 10"})," (",(0,n.jsx)(s.em,{children:"m"})," = 1,024 registers, ~1 KB):","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Sparse limit: 2^(10+5) = 32,768 distincts (error \u2248 0%)."}),"\n",(0,n.jsx)(s.li,{children:"Plateau begins at ~5\xb7m = 5,120 distincts."}),"\n",(0,n.jsx)(s.li,{children:"Steady\u2011state error: 0.83/\u221a1,024 \u2248 2.6%."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"p = 12"})," (",(0,n.jsx)(s.em,{children:"m"})," = 4,096 registers, ~4 KB):","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Sparse limit: 2^(12+5) = 131,072 distincts."}),"\n",(0,n.jsx)(s.li,{children:"Plateau begins at ~5\xb7m = 20,480 distincts."}),"\n",(0,n.jsx)(s.li,{children:"Steady\u2011state error: 0.83/\u221a4,096 \u2248 1.3%."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"p = 15"})," (",(0,n.jsx)(s.em,{children:"m"})," = 32,768 registers, ~32 KB):","\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Sparse limit: 2^(15+5) = 1,048,576 distincts."}),"\n",(0,n.jsx)(s.li,{children:"Plateau begins at ~5\xb7m = 163,840 distincts."}),"\n",(0,n.jsx)(s.li,{children:"Steady\u2011state error: 0.83/\u221a32,768 \u2248 0.46%."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"error-behavior-over-cardinality",children:"Error Behavior Over Cardinality"}),"\n",(0,n.jsx)(s.p,{children:"The relative error of an HLL++ sketch evolves through three phases:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Exact Counting Phase"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Cardinality \u2264 2^(p+5). The sketch operates in sparse mode with error close to 0%."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Bias Ramp Phase"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Cardinality between 2^(p+5) and approximately 5\xb7m. The sketch is in dense mode. Systematic bias increases gradually from near 0 up to the maximum bound."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Steady-State Phase"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Cardinality \u2265 5\xb7m. Relative error stabilizes at the theoretical bound of 0.83 / sqrt(m). Once in this phase, adding more distinct items does not change the sketch's register distribution shape\u2014so the error remains effectively constant. In other words, after enough uniques, the sketch \"plateaus,\" and error fluctuations are limited to the estimator's minimal random variance around that fixed bound."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"example-for-p--15-m--32768",children:"Example for p = 15 (m = 32,768)"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Exact in sparse mode (\u2264 1,048,576 items)"}),' - For up to 2^(p+5) = 2^20 = 1,048,576 distinct elements, HLL++ uses a compact "sparse" representation that records individual hashes directly\u2014resulting in an exact count (0% error).']}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Transition to dense mode & rising error"})," - Beyond 1,048,576 distinct elements, it switches to the full register array of size m = 2^p = 32,768. In this ",(0,n.jsx)(s.em,{children:"dense"})," regime, the Relative Standard Error (RSE) gradually increases from 0% to its theoretical limit."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Asymptotic error plateau (\u2248 0.46%)"})," - Once in dense mode, the RSE quickly converges to RSE \u2248 0.83/\u221am = 0.83/\u221a32,768 \u2248 0.46%, and remains at approximately 0.46% regardless of further increases in distinct count."]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"merging-sketches-over-time-or-partitions",children:"Merging Sketches Over Time or Partitions"}),"\n",(0,n.jsx)(s.p,{children:"To compute distinct counts across multiple segments (for example, daily sketches), we merge sketches by taking the element-wise maximum of their registers. This operation is associative and idempotent. Merged sketches preserve the same error bound as individual sketches and do not add additional error."}),"\n",(0,n.jsx)(s.h2,{id:"mathematical-formulation",children:"Mathematical Formulation"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.strong,{children:"Raw Estimate"})}),"\n"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"M[i]"})," is the value of register ",(0,n.jsx)(s.em,{children:"i"}),"."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"alpha_m"})," is a bias correction constant dependent on ",(0,n.jsx)(s.em,{children:"m"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:['This is the core HyperLogLog "raw" estimator for the number of distinct elements in a multiset. You take each register value M_i, compute ',(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msup,{children:[(0,n.jsx)(s.mn,{children:"2"}),(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mo,{children:"\u2212"}),(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"M"}),(0,n.jsx)(s.mi,{children:"i"})]})]})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"2^{-M_i}"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8413em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord",children:"2"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsx)(s.span,{className:"vlist-t",children:(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.8413em"},children:(0,n.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsxs)(s.span,{className:"mord mtight",children:[(0,n.jsx)(s.span,{className:"mord mtight",children:"\u2212"}),(0,n.jsxs)(s.span,{className:"mord mtight",children:[(0,n.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"M"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3281em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.357em",marginLeft:"-0.109em",marginRight:"0.0714em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.5em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size3 size1 mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.143em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]})})})})})]})]})})]}),", sum those values, invert that sum, and multiply by m^2 (where m is the number of registers) to get a harmonic-mean-based estimate. This is then scaled by the bias-correction constant \u03b1_m. In effect, this formula transforms the observed distribution of leading-zero counts into an approximate count of unique items."]}),"\n",(0,n.jsxs)(s.ol,{start:"2",children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"HIP Estimator"})}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Maintains a running sum of inverse probabilities for each new distinct element."}),"\n",(0,n.jsx)(s.li,{children:"Produces lower variance and a smaller worst-case error constant (0.83 instead of 1.04)."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Relative Standard Error (RSE)"})}),"\n",(0,n.jsx)(s.p,{children:"RSE \u2248 0.83/\u221am"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"best-practices-and-limitations",children:"Best Practices and Limitations"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Choose precision ",(0,n.jsx)(s.em,{children:"p"})," based on the maximum cardinality we expect and the error tolerance. (This will be done for you so you don't have to worry about it)"]}),"\n",(0,n.jsxs)(s.li,{children:["Once a sketch is created with precision ",(0,n.jsx)(s.em,{children:"p"}),", we cannot increase its precision later. We can only merge or downsample to lower precision."]}),"\n",(0,n.jsx)(s.li,{children:"Long keys or complex objects increase CPU and memory in sparse mode but do not affect dense mode size."}),"\n",(0,n.jsx)(s.li,{children:"Plan for a noise floor equal to the sketch's relative error when designing experiments or setting thresholds."}),"\n",(0,n.jsx)(s.li,{children:"Please reach out if you believe you require higher precision."}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"conclusion-and-recommendations",children:"Conclusion and Recommendations"}),"\n",(0,n.jsxs)(s.p,{children:["HLL++ sketches provide efficient, bounded- error approximations for ",(0,n.jsx)(s.code,{children:"count_distinct"})," queries. They trade a small, predictable error for large savings in memory and compute."]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Memory scales as O(m) rather than O(n)."}),"\n",(0,n.jsx)(s.li,{children:"Error scales as O(1/\u221am)."}),"\n",(0,n.jsx)(s.li,{children:"Merging sketches is exact for unions, with no extra error."}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["Select the smallest precision ",(0,n.jsx)(s.em,{children:"p"})," that meets your accuracy requirements to minimize storage and computation costs."]}),"\n",(0,n.jsx)(s.h2,{id:"choosing-precision-for-your-cardinality",children:"Choosing Precision for Your Cardinality"}),"\n",(0,n.jsxs)(s.p,{children:["When you know the maximum number of unique items (cardinality) ahead of time, pick a precision ",(0,n.jsx)(s.em,{children:"p"})," so that ",(0,n.jsx)(s.strong,{children:"5 \xb7 2^p"})," exceeds that cardinality. This ensures the sketch is in its steady\u2011state phase, where the relative error remains at the bound of 0.83/\u221a(2^p)."]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Up to 10,000 uniques"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"p"})," = 12 (m = 4,096 registers) \u2192 memory ~4 KB"]}),"\n",(0,n.jsx)(s.li,{children:"Steady state from ~20,480 distincts (5\xb7m) onward"}),"\n",(0,n.jsx)(s.li,{children:"Relative error \u2248 0.83/\u221a4,096 \u2248 1.3 %"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Up to 50,000 uniques"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"p"})," = 13 (m = 8,192 registers) \u2192 memory ~8 KB"]}),"\n",(0,n.jsx)(s.li,{children:"Steady state from ~40,960 distincts onward"}),"\n",(0,n.jsx)(s.li,{children:"Relative error \u2248 0.83/\u221a8,192 \u2248 0.92 %"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Up to 100,000 uniques"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"p"})," = 15 (m = 32,768 registers) \u2192 memory ~32 KB"]}),"\n",(0,n.jsx)(s.li,{children:"Steady state from ~163,840 distincts onward"}),"\n",(0,n.jsx)(s.li,{children:"Relative error \u2248 0.83/\u221a32,768 \u2248 0.46 %"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Up to 500,000 uniques"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"p"})," = 16 (m = 65,536 registers) \u2192 memory ~64 KB"]}),"\n",(0,n.jsx)(s.li,{children:"Steady state from ~327,680 distincts onward"}),"\n",(0,n.jsx)(s.li,{children:"Relative error \u2248 0.83/\u221a65,536 \u2248 0.32 %"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Up to 1,000,000 uniques"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"p"})," = 17 (m = 131,072 registers) \u2192 memory ~128 KB"]}),"\n",(0,n.jsx)(s.li,{children:"Steady state from ~655,360 distincts onward"}),"\n",(0,n.jsx)(s.li,{children:"Relative error \u2248 0.83/\u221a131,072 \u2248 0.23 %"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"General rule"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["Compute ",(0,n.jsx)(s.em,{children:"m"})," = 2^p"]}),"\n",(0,n.jsxs)(s.li,{children:["Ensure ",(0,n.jsx)(s.strong,{children:"5\xb7m \u2265 expected cardinality"})]}),"\n",(0,n.jsxs)(s.li,{children:["Verify memory footprint (",(0,n.jsx)(s.em,{children:"m"})," bytes) fits your budget"]}),"\n",(0,n.jsx)(s.li,{children:"Confirm relative error (0.83/\u221am) meets your accuracy target"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsx)(s.p,{children:"count_distinct gives you a simple, consistent way to measure breadth at scale. Define once, use everywhere, and merge across time and partitions with stable behavior. You get decision-ready answers to \u201cHow many unique X?\u201d without custom ETL or one-off SQL."}),"\n",(0,n.jsx)(s.h2,{id:"defaults-at-statsig",children:"Defaults at Statsig"}),"\n",(0,n.jsx)(s.p,{children:"By default, we set precision p = 12 for count_distinct. This works well for most use cases and keeps results stable and responsive. If you expect much higher cardinalities or need tighter bounds, please reach out and we\u2019ll help you choose the right setting."})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453:(e,s,i)=>{i.d(s,{R:()=>l,x:()=>a});var n=i(96540);const r={},t=n.createContext(r);function l(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);