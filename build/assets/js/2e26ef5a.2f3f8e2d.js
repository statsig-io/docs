"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[49219],{49225:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var n=i(74848),s=i(28453);const r={sidebar_label:"Configuration",title:"Configuring Experiments",keywords:["owner:craig"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},a="Configuration",o={id:"statsig-warehouse-native/features/experiment-options",title:"Configuring Experiments",description:'In Statsig Warehouse Native, there\'s a large amount of configurability in experiment setup and analysis. Statsig users should be able to run an experiment with "default" options and get powerful, trustworthy statistical analysis of your results, but in many cases an advanced configuration helps users maximize power and helps to measure exactly what is intended to be measured.',source:"@site/docs/statsig-warehouse-native/features/experiment-options.md",sourceDirName:"statsig-warehouse-native/features",slug:"/statsig-warehouse-native/features/experiment-options",permalink:"/statsig-warehouse-native/features/experiment-options",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/statsig-warehouse-native/features/experiment-options.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{sidebar_label:"Configuration",title:"Configuring Experiments",keywords:["owner:craig"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"warehouse",previous:{title:"Understanding Experiments",permalink:"/statsig-warehouse-native/features/understanding-experiments"},next:{title:"Configuring Experiments",permalink:"/statsig-warehouse-native/features/configure-an-experiment"}},l={},d=[{value:"Basic Settings",id:"basic-settings",level:2},{value:"Hypothesis",id:"hypothesis",level:3},{value:"Primary and Secondary Metrics",id:"primary-and-secondary-metrics",level:3},{value:"Experiment Duration",id:"experiment-duration",level:3},{value:"Experiment Configuration",id:"experiment-configuration",level:3},{value:"Assignment Source and Groups",id:"assignment-source-and-groups",level:3},{value:"Groups and Parameters",id:"groups-and-parameters",level:3},{value:"Advanced Settings",id:"advanced-settings",level:3},{value:"Pre-computed User Dimensions",id:"pre-computed-user-dimensions",level:3},{value:"Stratified Sampling",id:"stratified-sampling",level:3},{value:"ID Type and Secondary ID Type",id:"id-type-and-secondary-id-type",level:3},{value:"Allocation and Cohorting",id:"allocation-and-cohorting",level:3},{value:"Cure Covariates",id:"cure-covariates",level:3},{value:"Analysis Settings",id:"analysis-settings",level:3},{value:"Metrics",id:"metrics",level:2},{value:"Group By",id:"group-by",level:2},{value:"Filter",id:"filter",level:2},{value:"Time Range for Metric Data",id:"time-range-for-metric-data",level:2},{value:"Filter by Exposure Date",id:"filter-by-exposure-date",level:2},{value:"Scheduling",id:"scheduling",level:2},{value:"Interaction Effect Detection",id:"interaction-effect-detection",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"configuration",children:"Configuration"})}),"\n",(0,n.jsx)(t.p,{children:'In Statsig Warehouse Native, there\'s a large amount of configurability in experiment setup and analysis. Statsig users should be able to run an experiment with "default" options and get powerful, trustworthy statistical analysis of your results, but in many cases an advanced configuration helps users maximize power and helps to measure exactly what is intended to be measured.'}),"\n",(0,n.jsx)(t.p,{children:"This page is intended as a broad glossary for advanced experimentation settings - what they do, how to use them, and tradeoffs to be aware of."}),"\n",(0,n.jsx)(t.h1,{id:"experiment-settings",children:"Experiment Settings"}),"\n",(0,n.jsx)(t.h2,{id:"basic-settings",children:"Basic Settings"}),"\n",(0,n.jsx)(t.h3,{id:"hypothesis",children:"Hypothesis"}),"\n",(0,n.jsx)(t.p,{children:"Hypotheses are required to run experiments in Statsig. Hypotheses should specify what an experiment is aiming to accomplish, and how that will be measured."}),"\n",(0,n.jsx)(t.h3,{id:"primary-and-secondary-metrics",children:"Primary and Secondary Metrics"}),"\n",(0,n.jsx)(t.p,{children:"These are the metrics used as the evaluation criteria for your experiment. Generally, Statsig recommends a small number of primary metrics to use as your overall evaluation criteria, and to put guardrails and exploratory metrics into Secondary."}),"\n",(0,n.jsx)(t.p,{children:"There is project-level configuration of the maximum number of primary/secondary metrics available; this behavior varies by company and industry, as well as the complexity of the space being measured."}),"\n",(0,n.jsx)(t.h3,{id:"experiment-duration",children:"Experiment Duration"}),"\n",(0,n.jsxs)(t.p,{children:["In experiment setup there are fields for ",(0,n.jsx)(t.em,{children:"Experiment Measured In"})," and ",(0,n.jsx)(t.em,{children:"Target"}),". This allows configuration of how long your experiment should be run for, influencing sequential testing as well as notifications/timeline alerts."]}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsxs)(t.p,{children:["Statsig's ",(0,n.jsx)(t.a,{href:"/statsig-warehouse-native/features/power-analysis",children:"power analysis tools"})," are the best way to determine what the target duration should be. A power analysis can be attached to an experiment to add context on the duration."]})}),"\n",(0,n.jsx)(t.h3,{id:"experiment-configuration",children:"Experiment Configuration"}),"\n",(0,n.jsx)(t.h3,{id:"assignment-source-and-groups",children:"Assignment Source and Groups"}),"\n",(0,n.jsx)(t.p,{children:"For analysis-only experiments, this section will be pre-filled from the observed data in the data warehouse. Images and descriptions can be configured. Group sizes will be inferred, but should be reviewed and corrected if mismatched with the intended traffic split."}),"\n",(0,n.jsx)(t.p,{children:"This can be updated by resetting the experiment from the decision menu after it has started."}),"\n",(0,n.jsx)(t.h3,{id:"groups-and-parameters",children:"Groups and Parameters"}),"\n",(0,n.jsx)(t.p,{children:"For end-to-end experiments (experiments using Statsig for both assignment and analysis), this section is where targeting, layers, and finally the groups and associated parameters are configured. Exposures generated from the setup will automatically be associated with this experiment for analysis."}),"\n",(0,n.jsx)(t.h3,{id:"advanced-settings",children:"Advanced Settings"}),"\n",(0,n.jsx)(t.p,{children:"There are a large number of advanced settings available for customizing analysis. These can have complex interactions with data."}),"\n",(0,n.jsx)(t.h3,{id:"pre-computed-user-dimensions",children:"Pre-computed User Dimensions"}),"\n",(0,n.jsx)(t.p,{children:"Dimensions can be configured as default breakdowns in pulse. That is, a user dimension (e.g. country) can be specified here and it will be available in the scorecard results with daily loads."}),"\n",(0,n.jsx)(t.p,{children:'This allows users to skip the process of doing scheduled explore queries for this dimension, and allows the results to be available "inline" in their scorecard.'}),"\n",(0,n.jsx)(t.h3,{id:"stratified-sampling",children:"Stratified Sampling"}),"\n",(0,n.jsxs)(t.p,{children:["Stratified Sampling allows users to balance their experiments across behavior or segments. This is achieved by testing random salts, and picking the one that best-balances user attributions. This can be partially achieved during analysis using ",(0,n.jsx)(t.a,{href:"/experiments-plus/cure/",children:"CURE"}),"\nSee ",(0,n.jsx)(t.a,{href:"/experiments-plus/stratified-sampling",children:"Stratified Sampling"})," for further documentation."]}),"\n",(0,n.jsx)(t.h3,{id:"id-type-and-secondary-id-type",children:"ID Type and Secondary ID Type"}),"\n",(0,n.jsxs)(t.p,{children:["The ID type, which is the unit of randomization for an experiment, is configured when setting up the experiment and is a critical field. This represents the kind of entity being experimented on. For example, if splitting traffic randomly per user, this should be ",(0,n.jsx)(t.code,{children:"User ID"}),". If splitting traffic by company, this should be ",(0,n.jsx)(t.code,{children:"Company ID"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Secondary ID types are used to associate metrics on a different ID with the unit of randomization. Concretely, if running an experiment on a logged out cookie ID, specifying ",(0,n.jsx)(t.code,{children:"UserID"})," as a secondary ID allows easy analysis of ",(0,n.jsx)(t.code,{children:"UserID"})," metrics like revenue, while keeping ",(0,n.jsx)(t.code,{children:"Cookie ID"}),"s as the unit of analysis (e.g. the denominator in means). This is a powerful way to understand downstream impact of your experiments without introducing survivorship bias or other bias to the analysis."]}),"\n",(0,n.jsxs)(t.p,{children:["This mapping can come directly from the assignment source. If multiple exposures are logged for a given unit, and at least one has both ID types, Statsig will identify that these two IDs are mapped to each other. Alternately, mappings can be specified in an Entity Property Source - just provide a mapping table of ",(0,n.jsx)(t.code,{children:"ID1"})," to ",(0,n.jsx)(t.code,{children:"ID2"})," and Statsig will connect the data during analysis."]}),"\n",(0,n.jsxs)(t.p,{children:["Secondary ID mapping can be configured as an enforced 1:1 mapping, or as a first-touch attribution. Refer to the ",(0,n.jsx)(t.a,{href:"/statsig-warehouse-native/features/id-resolution",children:"full documentation"})," for more details."]}),"\n",(0,n.jsx)(t.h3,{id:"allocation-and-cohorting",children:"Allocation and Cohorting"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Configure Allocation Duration"})}),"\n",(0,n.jsxs)(t.p,{children:["If using a persistent assignment SDK (",(0,n.jsx)(t.a,{href:"/client/concepts/persistent_assignment",children:"docs"}),"), this setting controls when to stop enrolling users into the experiment."]}),"\n",(0,n.jsx)(t.p,{children:"This can also be used without a persistent assignment SDK to filter users after the duration period from the analysis - this use case is helpful for enforcing even cohorts across a userbase. For example, if a metric takes 7 days to mature, and stopping the experiment will halt the experiment effect, setting the allocation duration to 14 days and running the experiment for 21 days will analyze the first 14 days of exposed units while analyzing all 7 days of the last cohort's metric behavior."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Configure Analysis Period"})}),"\n",(0,n.jsx)(t.p,{children:"This is similar to the allocation duration, but controls the dates from which metric data will be collected. This is useful for truncating the analysis while continuing to run an experiment"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Allow cohort metrics to mature after experiment end"})}),"\n",(0,n.jsx)(t.p,{children:"This setting allows cohort or baked metrics that take time to mature to continue collecting data after the end of an experiment. This is only recommended if an experiment is a one-time intervention."}),"\n",(0,n.jsx)(t.p,{children:'For example, consider a 14 day experiment on new users that modifies a signup page. Removing the changes to the signup page does not impact users who already saw it, so to maximize data for "first-week revenue" metric, this setting can be checked and data will continue to collect for users enrolled on the 14th day until the 21st day, or for users enrolled on the 10th day until the 17th day, even though the experiment is no longer running after the 14th day.'}),"\n",(0,n.jsx)(t.h3,{id:"cure-covariates",children:"Cure Covariates"}),"\n",(0,n.jsxs)(t.p,{children:["This section allows configuration of covariates for CURE. It is recommended to configure strong defaults in the project settings, and use this to add relevant/domain-specific covariates. See the ",(0,n.jsx)(t.a,{href:"/experiments-plus/cure/",children:"CURE"})," documentation for more details."]}),"\n",(0,n.jsx)(t.h3,{id:"analysis-settings",children:"Analysis Settings"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Analytics Type"})}),"\n",(0,n.jsx)(t.p,{children:"Whether to use Frequentist or Bayesian analysis. This cannot be changed once an experiment starts to avoid cherry-picking methodology."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Apply Sequential Testing [Frequentist Only]"})}),"\n",(0,n.jsxs)(t.p,{children:["Controls whether ",(0,n.jsx)(t.a,{href:"/experiments-plus/sequential-testing",children:"sequential testing"})," is applied. This setting is recommended to avoid false positives from peeking."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Bonferroni/Benjamini-Hochberg [Frequentist Only]"})}),"\n",(0,n.jsxs)(t.p,{children:["Configures multiple-comparisons corrections - either controlling the false positive rate or false discovery rate. Refer to the more detailed documentation for ",(0,n.jsx)(t.a,{href:"/stats-engine/methodologies/bonferroni-correction",children:"Bonferroni"})," and ",(0,n.jsx)(t.a,{href:"/stats-engine/methodologies/benjamini%E2%80%93hochberg-procedure",children:"Benjamini-Hochberg"}),"."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Default Confidence Interval/Chance to Beat Threshold"})}),"\n",(0,n.jsx)(t.p,{children:"The confidence level used for this experiment. By default this is 95%, which is a strongly recommended default and industry standard. However, depending on the risk profile of the experiment and the risk tolerance of the experimenter, it might make sense to use a stricter or less strict setting in some cases."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Use Informative Priors [Bayesian Only]"})}),"\n",(0,n.jsx)(t.p,{children:"For bayesian experiments, whether to use informed priors in analysis, and the configuration for them."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Turbo Mode"})}),"\n",(0,n.jsxs)(t.p,{children:["Whether to use ",(0,n.jsx)(t.a,{href:"/statsig-warehouse-native/features/turbo",children:"Turbo Mode"})," to run experiment reloads more quickly."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Filter Exposures by Qualifying Event"})}),"\n",(0,n.jsx)(t.p,{children:"This setting allows filtering exposures to experimental units that did (or did not) trigger a secondary event beyond exposure. This is very useful for analysis-only experiments on web experimentation platforms that over-expose heavily. Generally for end-to-end experiments we recommend using statsig to expose only at the point of intervention."}),"\n",(0,n.jsx)(t.p,{children:"This setting has a few inputs:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"A qualifying event, which is joined to exposures to understand if users triggered an event"}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Exclude Matching Units"})," - if toggled, units that triggered this event will be ",(0,n.jsx)(t.em,{children:"dropped from the analysis"}),". If unchecked, the analysis will be filtered to units that triggered the event."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Use qualifying event timestamp for first exposures"})," if checked, units' exposure timestamp will be replaced with the qualifying event's timestamp. This is useful for small cohort windows - e.g. wanting to measure if something happened within 10 minutes of the intervention. If the intervention occurred several minutes after the original exposure event, it can be helpful to use the actual time that the user saw the intervention"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Filter events by time window"})," only consider qualifying events for the inclusion/exclusion filters which occurred within a certain time from the exposure. This is useful if a user may come back and re-trigger the qualifying event when it's no longer relevant to the exposure."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Filter Assignment Source"})}),"\n",(0,n.jsx)(t.p,{children:"This setting controls additional filters to be applied to the exposure data for this experiment. This can be useful to filter out bad dates with data that is known to be biased or non-representative, or to filter to a specific subset of interest for the scorecard results."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Default Rollup Window"})}),"\n",(0,n.jsx)(t.p,{children:"Statsig calculates results across multiple rollups. Cumulative is almost always the correct choice for this setting, as it maximizes statistical power and the other views can be easily switched to in the scorecard."}),"\n",(0,n.jsx)(t.h1,{id:"explore-custom-query-settings",children:"Explore (Custom) Query Settings"}),"\n",(0,n.jsx)(t.p,{children:"Explore queries enable drilldown, filtering, grouping, and more advanced ways to cut metric data by user and metric properties. These are a way to to deeply understand experiment results. On Statsig, explore queries run with the same statistics as the scorecard; with no filters or other settings, results should match the scorecard results."}),"\n",(0,n.jsx)(t.h2,{id:"metrics",children:"Metrics"}),"\n",(0,n.jsx)(t.p,{children:"Pick the metrics to run the explore/drilldown analysis on - this can include tags and local metrics."}),"\n",(0,n.jsx)(t.h2,{id:"group-by",children:"Group By"}),"\n",(0,n.jsxs)(t.p,{children:["This setting is the bread and butter of explore/custom queries and allows drilldowns into user segments. This is used to understand differentiate performance and can be combined with ",(0,n.jsx)(t.a,{href:"/experiments-plus/differential-impact-detection",children:"differential impact detection"})," to deeply understand experiment results beyond topline averages."]}),"\n",(0,n.jsx)(t.p,{children:"By default only the top 10 dimension levels with over 100 units per segment are shown in results. The rest are grouped into an OTHER category. This is to prevent aggravated false positive rates and keep statistical analysis rigorous; reach out in slack if this needs adjustment."}),"\n",(0,n.jsx)(t.h2,{id:"filter",children:"Filter"}),"\n",(0,n.jsx)(t.p,{children:"Filters can be used to include/exclude certain cohorts of units in an explore analysis by specifying the property and a filter-set for it."}),"\n",(0,n.jsx)(t.h2,{id:"time-range-for-metric-data",children:"Time Range for Metric Data"}),"\n",(0,n.jsx)(t.p,{children:"This setting filters metric data to a certain date period; e.g., seeing the results for all users on the 3 days from April 10 to April 12. This can be useful to understand blips in data, get a recent cohort if results have changed dramatically, or generally run drill-down analyses."}),"\n",(0,n.jsx)(t.h2,{id:"filter-by-exposure-date",children:"Filter by Exposure Date"}),"\n",(0,n.jsx)(t.p,{children:"In some cases it is useful to filter to units that entered the experiment on a certain date, or filter those out (e.g. units exposed on Christmas may behave oddly). This option allows users to specify filters based on user exposure date and remove them from analysis."}),"\n",(0,n.jsx)(t.p,{children:"By switching the mode to Days Since First Exposure, users can also drill down into each cohort's behavior during a certain window post-exposure. This is a great way to understand behaviors observed in the days-since-first-exposure timeline view."}),"\n",(0,n.jsx)(t.h2,{id:"scheduling",children:"Scheduling"}),"\n",(0,n.jsx)(t.p,{children:"After running a query, it can be scheduled. This query will be run daily after any scheduled pulse load to update the results. Scheduled queries can also be put into the experiment Summary page as part of the experiment writeup and downloadable summary."}),"\n",(0,n.jsx)(t.h2,{id:"interaction-effect-detection",children:"Interaction Effect Detection"}),"\n",(0,n.jsxs)(t.p,{children:["Explore queries can be used to trigger ",(0,n.jsx)(t.a,{href:"/experiments-plus/interaction-detection",children:"interaction effect detection"})," analyses to understand if two experiments are interacting in a synergistic or destructive fashion."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>a,x:()=>o});var n=i(96540);const s={},r=n.createContext(s);function a(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);