"use strict";(self.webpackChunkstatsig_docs=self.webpackChunkstatsig_docs||[]).push([[47608],{25178:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=s(74848),n=s(28453);const r={title:"Warehouse Storage",slug:"/statsig-warehouse-native/warehouse-management/storage",sidebar_label:"Warehouse Storage",keywords:["owner:craig"],last_update:{date:new Date("2025-09-18T00:00:00.000Z")}},i=void 0,o={id:"statsig-warehouse-native/warehouse-management/storage",title:"Warehouse Storage",description:"Introduction",source:"@site/docs/statsig-warehouse-native/warehouse-management/storage.md",sourceDirName:"statsig-warehouse-native/warehouse-management",slug:"/statsig-warehouse-native/warehouse-management/storage",permalink:"/statsig-warehouse-native/warehouse-management/storage",draft:!1,unlisted:!1,editUrl:"https://github.com/statsig-io/docs/edit/main/docs/statsig-warehouse-native/warehouse-management/storage.md",tags:[],version:"current",lastUpdatedAt:17581536e5,frontMatter:{title:"Warehouse Storage",slug:"/statsig-warehouse-native/warehouse-management/storage",sidebar_label:"Warehouse Storage",keywords:["owner:craig"],last_update:{date:"2025-09-18T00:00:00.000Z"}},sidebar:"warehouse",previous:{title:"Egress, Privacy, & Storage",permalink:"/statsig-warehouse-native/data-privacy"},next:{title:"Warehouse Costs",permalink:"/statsig-warehouse-native/guides/costs"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Conventions / Usage",id:"conventions--usage",level:2},{value:"Volume",id:"volume",level:2},{value:"Management",id:"management",level:2},{value:"Troubleshooting Storage Issues",id:"troubleshooting-storage-issues",level:2},{value:"Missing Data Errors",id:"missing-data-errors",level:3},{value:"Resolution Steps",id:"resolution-steps",level:4},{value:"Understanding Storage Dependencies",id:"understanding-storage-dependencies",level:4}];function c(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(t.p,{children:"Statsig uses its sandbox in your warehouse to cache intermediate tables and result tables. This allows incremental reloads - not recalculating metrics for every day of the experiment on each load - and allows the use of these tables for additional ad-hoc analysis."}),"\n",(0,a.jsx)(t.p,{children:"These tables will be stored in the sandbox schema or dataset configured for statsig. You can use this to track storage footprint and manage permissions easily."}),"\n",(0,a.jsx)(t.h2,{id:"conventions--usage",children:"Conventions / Usage"}),"\n",(0,a.jsxs)(t.p,{children:["Tables are generally sharded by entity ID. For example, the experiment ",(0,a.jsx)(t.code,{children:"early_user_journey_acceleration"})," would have that identifier in its associated table names for scorecard loads. This is an easy way to look up tables for a given experiment."]}),"\n",(0,a.jsx)(t.p,{children:"Statsig has special tables that it writes to. These can be found in metric sources or assignment sources:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"pipeline overview, where the performance statistics for the jobs Statsig runs are written"}),"\n",(0,a.jsx)(t.li,{children:"statsig_forwarded_events, where events logged via statsig.log_event are forwarded"}),"\n",(0,a.jsx)(t.li,{children:"statsig_forwarded_exposures, where exposures from experiments, gates, autotunes, and holdouts are sent"}),"\n",(0,a.jsx)(t.li,{children:"statsig_forwarded_switchback_exposures, where switchback-formatted exposures are sent"}),"\n",(0,a.jsx)(t.li,{children:"statsig_daily_results, where rendered results with statistics like p-value are sent"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Some of the above have pre-set table names, and some table names are configured in data connection settings."}),"\n",(0,a.jsx)(t.p,{children:"Many users ingest these tables as part of internal pipelines. We recommend configuring lookback windows such that mutable data does not cause issues, as data is regularly updated in the tables above, and in some cases will be backfilled up to several days in cases of data delays or repairs."}),"\n",(0,a.jsx)(t.p,{children:'Additionally, exposures do not necessarily dedupe, since fast-forwarded exposures will duplicate records from daily exports, and statsig only holds on to 30d of history for warehouse native projects - meaning after 30 days a given unit\'s exposure will be "new" and re-exported.'}),"\n",(0,a.jsx)(t.h2,{id:"volume",children:"Volume"}),"\n",(0,a.jsx)(t.p,{children:"Scorecard loads will generate a varied number of tables depending on factors like the number of metric sources accessed and the types of metrics loaded. Additionally, depending on data volumes Statsig may choose to materialize intermediate tables before or after large operations; this dramatically reduces compute cost incurred."}),"\n",(0,a.jsx)(t.p,{children:"This can lead to a large number of artifacts; customers running 300+ experiments have run into default quota limits on vendors like databricks. This can be managed by requesting a free quota increase or utilizing the TTLs described below in the management settings."}),"\n",(0,a.jsx)(t.h2,{id:"management",children:"Management"}),"\n",(0,a.jsx)(t.p,{children:"Transient tables have a short ttl - usually 1-2 days - and will be automatically cleaned up."}),"\n",(0,a.jsx)(t.p,{children:"Other tables are permanent by default, and can be cleaned up from the experiment in statsig's console or as part of launching an experiment. Additionally, TTLs can be configured for tables by type in the data connection section of a project's settings."}),"\n",(0,a.jsx)(t.p,{children:"It may also make sense to manage storage programmatically via your own warehouse tools, e.g. cleaning up entities which have not been accessed or modified in the last month. Generally this is not necessary given TTLs, but in some cases failures can occur and Statsig's internal tracking can consider a table dropped when it still has a storage footprint."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"How TTLs work"}),"\nWhen Statsig creates or modified a table it manages, it will use the current TTL setting to schedule a cleanup of that table at the current time + the TTL. For example, if a Result table is being written on 6/1, and Result tables are configured with a 14-day TTL, a deletion will be scheduled for 6/15."]}),"\n",(0,a.jsx)(t.p,{children:"If that table were modified on 6/7 (e.g. through a scorecard reload), the deletion request would be set to 6/21, overwriting the existing one. In this way, incremental updates on long-running experiments keep their staging data until the experiment stops."}),"\n",(0,a.jsx)(t.p,{children:"This does mean that changing TTLs will not retroactively impact existing tables' deletion requests until a scorecard load is run for the relevant experiment."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Types of Tables for TTL"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Result Datasets"})," are the final tables Statsig creates at the end of an experiment or gate reload that contain the aggregated group-metric level data. These are generally pretty small (1 row per metric/day/group/dimension) and useful for post-hoc analysis"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Intermediate Tables"})," are all the other tables Statsig writes to throughout the course of an experiment reload; these can be large since they can contain user-level data. These are re-used for incremental and metric reloads."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Transient Datasets"})," refer to tables created for one-off queries (most commonly Explore queries and Power Analyses), or temporary datasets used while creating ",(0,a.jsx)(t.code,{children:"Intermediate Tables"})," as a performance optimization. By default, these are dropped after 2-3 days (unless overridden with the setting above)"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Explore Query Dependencies"}),": Explore queries rely specifically on permanent staging tables for functionality. These tables are used to reduce the need to re-compute data for analysis that was already performed by the scorecard run. Unlike results tables which are cached locally on Statsig servers, permanent staging tables must be maintained in your warehouse for explorer queries to function properly; this is to avoid regressing large volumes of data that may contain PII or other sensitive information."]}),"\n",(0,a.jsx)(t.h2,{id:"troubleshooting-storage-issues",children:"Troubleshooting Storage Issues"}),"\n",(0,a.jsx)(t.h3,{id:"missing-data-errors",children:"Missing Data Errors"}),"\n",(0,a.jsxs)(t.p,{children:["Warehouse Native users may encounter ",(0,a.jsx)(t.code,{children:"TABLE_OR_VIEW_NOT_FOUND"})," errors, or similar, when required data tables are missing from your warehouse. This typically occurs when:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Permanent staging tables have been dropped"}),": Explore queries and advanced analysis rely specifically on permanent staging tables, not results or transient staging tables"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"TTL settings have expired tables"}),": Tables with configured time-to-live (TTL) settings may be automatically cleaned up"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Incomplete data loads"}),": Initial experiment setup or data pipeline issues may prevent table creation"]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"resolution-steps",children:"Resolution Steps"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"For Missing Staging Tables:"}),"\nMissing permanent staging tables require a full reload to recreate the staging dataset."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"For General Missing Tables:"})}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Check your warehouse's TTL settings in the data connection configuration"}),"\n",(0,a.jsx)(t.li,{children:"Verify that permanent staging tables exist in your configured sandbox schema"}),"\n",(0,a.jsx)(t.li,{children:"If tables were manually dropped, trigger a full data reload"}),"\n",(0,a.jsx)(t.li,{children:"Contact support if tables continue to be missing after reload, or if you didn't drop them"}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"understanding-storage-dependencies",children:"Understanding Storage Dependencies"}),"\n",(0,a.jsx)(t.p,{children:"Warehouse Native uses several types of tables with different storage patterns:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Permanent staging tables"}),": Required for explore queries and advanced analysis functionality"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Transient staging tables"}),": Short-lived intermediate tables with a mix of automatic cleanup (1-2 days TTL) and permanent storage (small tables that are useful for ad-hoc analysis like regression coefficients)."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Results tables"}),": Output statistics from the pipeline, which are copied and cached locally on Statsig servers"]}),"\n"]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"Vacuum jobs do not affect staging tables used by Statsig."})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>o});var a=s(96540);const n={},r=a.createContext(n);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);